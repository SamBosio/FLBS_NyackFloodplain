---
title: "Nyack_Floodplain_Flood_Dynamics"
author: "Amalia Handler"
date: "1/24/2020"
output: 
  html_document: 
    keep_md: yes
editor_options: 
  chunk_output_type: console
---

This script is used to investigate the influence of Middle Fork of the Flathead River floods on the Nyack Floodplain. The data (temperature, dissolved oxygen, conductivity, and water level) include six groundwater wells and three surface water wells.

Note that the data used here has been QAQC'ed through removal of bad data associated with sensor error and servicing using the script titled "Nyack_Floodplain_Water_QAQC.Rmd" available on Amalia Handler's GitHub repository amaliahandler/FLBS_NyackFloodplain.


```{r}
# Load packages

# Load data
options(stringsAsFactors = FALSE)
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

```


Visualize the how floods on the mainstem influence the groundwater wells.


```{r}
# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
level <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2),]

# Convert datetime to POSIX variable type
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(level) <- sensor

# Find the latest start date for each sensor
min_dates <- lapply(level, function(x){min(x$datetime)})

latest_start <- max(do.call("c", min_dates))

# Subset each sensor such that all have the same start datetime
level <- lapply(level, function(x){x[x$datetime >= latest_start,]})

# Make figure of entire time series
y_label   <- "Level (m)"

png("./Figures/Flood Figures/GW Level by Rank.png", units = "in", 
    width = 8, height = 12, res = 100, bg = "transparent")

par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))

lapply(level, function(x){
  plot(x$datetime, x$level_m, xlab = " ", ylab = y_label, 
       cex.lab = 2, cex.axis = 2, pch = 20)

  title(paste(x[1,2], x[1,1], sep = '_'), 
        line = 0.5, cex.main = 2)
  
  box(lwd = 2)
  })

dev.off()

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Level (m)"
  
  # Standardize the y axis limits based on the CASC sensor
  # Find the max and min of the water level data for CASC
  temp <- level$`6`[level$`6`$datetime >= start & level$`6`$datetime <= end,]
  max_level <- max(temp$level_m)
  min_level <- min(temp$level_m)
  casc_diff <- (max_level - min_level) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW Level by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(level, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_level <- max(temp$level_m)
    min_level <- min(temp$level_m)
    mid_point <- (max_level - min_level) / 2
    ylim_up   <- (min_level + mid_point) + casc_diff
    ylim_lo   <- (min_level + mid_point) - casc_diff
    
    plot(temp$datetime, temp$level_m, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}


```


Make a set of figures for the DO temperature sensor


```{r}
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)

# Temperature flood data from the DO sensor
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
do <- do[-which(do$do_temp == -999 | do$do_temp_flag == 1 | do$do_temp_flag == 2),]

# Convert datetime to POSIX variable type
do$datetime <- as.POSIXct(do$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

do  <- merge(do, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
do <- do[do$sensor_number %in% sensor,]

# Break the df into a list based on rank
do <- split(do, f = as.factor(do$rank))

# Make the names the sensor number
names(do) <- sensor

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Temp (C)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(do, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$do_temp) - min(temp$do_temp)
                })
  
  max_diff  <- max(dat_range) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW Temp by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(do, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_temp <- max(temp$do_temp)
    min_temp <- min(temp$do_temp)
    mid_point <- (max_temp - min_temp) / 2
    ylim_up   <- (min_temp + mid_point) + max_diff
    ylim_lo   <- (min_temp + mid_point) - max_diff
    
    plot(temp$datetime, temp$do_temp, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```




Make a set of figures for the DO saturation sensor




```{r}
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)

# DO saturation flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
do <- do[-which(do$do_sat == -999 | do$do_sat_flag == 1 | do$do_sat_flag == 2),]

# Convert datetime to POSIX variable type
do$datetime <- as.POSIXct(do$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

do  <- merge(do, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
do <- do[do$sensor_number %in% sensor,]

# Break the df into a list based on rank
do <- split(do, f = as.factor(do$rank))

# Make the names the sensor number
names(do) <- sensor

# Testing
i <- 2013
x <- do$`6`

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "DO Sat (%)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(do, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$do_sat) - min(temp$do_sat)
                })
  
  max_diff  <- max(dat_range) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW DO Sat by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(do, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_sat   <- max(temp$do_sat)
    min_sat   <- min(temp$do_sat)
    mid_point <- (max_sat - min_sat) / 2
    ylim_up   <- (min_sat + mid_point) + max_diff
    ylim_lo   <- (min_sat + mid_point) - max_diff
    
    plot(temp$datetime, temp$do_sat, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```


Make a set of figures for the conductivity


```{r}
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)

# Conductivity flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
cond <- cond[-which(cond$cond == -999 | cond$cond_flag == 1 | cond$cond_flag == 2),]

# Convert datetime to POSIX variable type
cond$datetime <- as.POSIXct(cond$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

cond   <- merge(cond, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
cond <- cond[cond$sensor_number %in% sensor,]

# Break the df into a list based on rank
cond <- split(cond, f = as.factor(cond$rank))

# Make the names the sensor number
names(cond) <- sensor

# Testing
i <- 2013
x <- cond$`6`

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Cond (mS)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(cond, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$cond) - min(temp$cond)
                })
  
  max_diff  <- max(dat_range) / 2

  png(paste0("./Figures/Flood Figures/", year,"_GW Cond by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(cond, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_cond  <- max(temp$cond)
    min_cond  <- min(temp$cond)
    mid_point <- (max_cond - min_cond) / 2
    ylim_up   <- (min_cond + mid_point) + max_diff
    ylim_lo   <- (min_cond + mid_point) - max_diff
    
    plot(temp$datetime, temp$cond, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```


Visuals of some key representative wells that show the influence of floods
CASC main channel
HA02_9, GW sensor closest to the main channel
HA07_3, GW sensor farthest from the main channel

Show time series for 2014 and 2013-2018 for water level, temperature, DO % saturation, and conductivity


```{r}
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Remove bad and questionable data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)
cond    <- cond[-which(cond$cond == -999 | cond$cond_flag == 1 | 
                         cond$cond_flag == 2),]
do_sat  <- do[-which(do$do_sat == -999 | do$do_sat_flag == 1 | 
                       do$do_sat_flag == 2),]
level   <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | 
                          level$level_m_flag == 2),]
do_temp <- do[-which(do$do_temp == -999 | 
                       do$do_temp_flag == 1 | do$do_temp_flag == 2),]

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
rank   <- data.frame(sensor = c(6,9,3), rank = c(1:3))

merge_rank <- function(x){
  merge(x, rank, by.x = "sensor_number", by.y = "sensor")
}

cond    <- merge_rank(cond)
do_sat  <- merge_rank(do_sat)
do_temp <- merge_rank(do_temp)
level   <- merge_rank(level)

# Convert datetime to POSIX variable type
time_to_POSIX <- function(x){
  as.POSIXct(x$datetime, tz = "MST")
}

cond$datetime    <- time_to_POSIX(cond)
do_sat$datetime  <- time_to_POSIX(do_sat)
level$datetime   <- time_to_POSIX(level)
do_temp$datetime <- time_to_POSIX(do_temp)

# For ease of looping, rename the key variable for visuals "value"
colnames(do_temp)[5] <- "value"
colnames(do_sat)[6]  <- "value"
colnames(level)[4]   <- "value"
colnames(cond)[4]    <- "value"

# Break the df into a list based on rank
list_cenversion <- function(x){
  split(x, f = as.factor(x$rank))
}

cond    <- list_cenversion(cond)
do_sat  <- list_cenversion(do_sat)
do_temp <- list_cenversion(do_temp)
level   <- list_cenversion(level)

# Make figure of 2014 data
# Level over temp on the left
# DO sat over temp on the right
year      <- 2014
start     <- as.POSIXct(paste0(year, "-01-01"))
end       <- as.POSIXct(paste0(year, "-12-31"))

# Standardize the y axis limits based on the sensor with the largest range of values
find_max_diff <- function(list){
  dat_range <- sapply(list, function(x){
                temp <- x[x$datetime >= start & x$datetime <= end,]
                dat_range <- max(temp$value) - min(temp$value)
              })
  max_diff  <- max(dat_range) / 2
}

max_diff_level <- find_max_diff(level)
max_diff_temp  <- find_max_diff(do_temp)
max_diff_sat   <- find_max_diff(do_sat)
max_diff_cond  <- find_max_diff(cond)

# Draw order (left to right, then up to down)
# Water level 6, Cond 6
# water level 9, cond 9
# Water level 3, cond 3
# Temp 6, DO sat 6
# Temp 9, DO sat 9
# Temp 3, DO sat 3
draw_order <- data.frame(df = c(rep(c("level", "cond"), 3), 
                                rep(c("do_temp", "do_sat"), 3)),
                         sensor = c(rep(c(6,6,9,9,3,3), 2)),
                         rank = c(rep(c(1,1,2,2,3,3), 2)))

df <- tmp
max_diff <- max_diff_level
y_label <- "Level (m)"

# Function to draw each plot
plot_draw <- function(df, max_diff, y_label, color){
    temp      <- df[df$datetime >= start & df$datetime <= end,]
    max_val   <- max(temp$value)
    min_val   <- min(temp$value)
    mid_point <- (max_val - min_val) / 2
    ylim_up   <- (min_val + mid_point) + max_diff
    ylim_lo   <- (min_val + mid_point) - max_diff
    
    plot(temp$datetime, temp$value, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20, col = color)
  
    title(paste(temp[1,2], temp[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
}

# Create the massive, 6 by 2 plot
png(paste0("./Figures/Flood Figures/", year,"_GW Comparison All Variables.png"), 
    units = "in", width = 14, height = 12, res = 1000, bg = "transparent")

par(mfrow = c(6,2), oma = c(2,2,1,1), mar = c(3,5,2,0))

# Loop to create the plot
for(i in 1:nrow(draw_order)){
  if(draw_order$df[i] == "level"){
    tmp <- level[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_level, "Level (m)", "black")
    
  } else if(draw_order$df[i] == "cond"){
    tmp <- cond[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_cond, "Cond (mS)", "darkgrey")
    
  } else if(draw_order$df[i] == "do_temp"){
    tmp <- do_temp[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_temp, "Temp (C)", "darkblue")
    
  } else{
    tmp <- do_sat[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_sat, "DO % Sat", "darkslategrey")
  }
  print(draw_order[i,])
}

dev.off()





# Same type of plot, but for the period between 2013 and 2018
start     <- as.POSIXct("2013-01-01")
end       <- as.POSIXct("2018-12-31")

max_diff_level <- find_max_diff(level)
max_diff_temp  <- find_max_diff(do_temp)
max_diff_sat   <- find_max_diff(do_sat)
max_diff_cond  <- find_max_diff(cond)

# Create the massive, 6 by 2 plot
png(paste0("./Figures/Flood Figures/2013-2018 GW Comparison All Variables.png"), 
    units = "in", width = 18, height = 12, res = 1000, bg = "transparent")

par(mfrow = c(6,2), oma = c(2,2,1,1), mar = c(3,5,2,0))

# Loop to create the plot
for(i in 1:nrow(draw_order)){
  if(draw_order$df[i] == "level"){
    tmp <- level[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_level, "Level (m)", "black")
    
  } else if(draw_order$df[i] == "cond"){
    tmp <- cond[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_cond, "Cond (mS)", "darkgrey")
    
  } else if(draw_order$df[i] == "do_temp"){
    tmp <- do_temp[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_temp, "Temp (C)", "darkblue")
    
  } else{
    tmp <- do_sat[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_sat, "DO % Sat", "darkslategrey")
  }
  print(draw_order[i,])
}

dev.off()



```



Analyze the lag in water level change due to floods across wells


```{r}
library(dplyr)

level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
level <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2),]

# Convert datetime to POSIX variable type
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(level) <- sensor

# For testing functions below
start_date <- "2015-03-25"
end_date   <- "2013-04-10"

# Function to standardize the size of the y axis range in figures
find_max_diff <- function(list){
  dat_range <- sapply(list, function(x){
                temp <- x[x$datetime >= start & x$datetime <= end,]
                dat_range <- max(temp$level_m) - min(temp$level_m)
              })
  max_diff  <- max(dat_range) / 2
}


# Function to find the time difference between peak water level in the main stem and the groundwater wells
gw_lags <- function(start_date, end_date){
  # Define period of time containing flood
  start <- as.POSIXct(start_date)
  end   <- as.POSIXct(end_date)
  
  # Get the time of peak water level at CASC
  temp <- level$`6`[level$`6`$datetime >= start & level$`6`$datetime <= end,]
  casc_max_lev <- max(na.omit(temp$level_m))
  casc_time_max <- temp[match(casc_max_lev, temp$level_m), "datetime"]
  
  # Plot the GW level relative to CASC
  max_diff <- find_max_diff(level)
  
  png(paste0("./Figures/Flood Figures/GW Level_", start_date,"_", end_date, ".png"), units = "in", width = 12, height = 12, res = 100, bg = "transparent")
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  lapply(level, function(x){
      temp      <- x[x$datetime >= start & x$datetime <= end,]
      max_val   <- max(temp$level_m)
      min_val   <- min(temp$level_m)
      mid_point <- (max_val - min_val) / 2
      ylim_up   <- (min_val + mid_point) + max_diff
      ylim_lo   <- (min_val + mid_point) - max_diff
    plot(temp$datetime, temp$level_m, xlab = " ", ylab = "Level (m)", 
         xlim = c(start, end), xaxs = 'i', yaxs = 'i',
         cex.lab = 2, cex.axis = 2, pch = 20)
    abline(v = casc_time_max, lwd = 3, col = "blue")
    title(paste(temp[1,2], temp[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    box(lwd = 2)
    })
  dev.off()
  
  # Find the corresponding time of max level in GW wells  
  for(i in 2:7){
    temp <- level[[i]][level[[i]]$datetime >= start & level[[i]]$datetime <= end,]
    max_lev <- max(na.omit(temp$level_m))
    max_t <- temp[match(max_lev, temp$level_m), "datetime"]
    ifelse(i == 2, max_time <- max_t, max_time[i-1] <- max_t)
  }
  
  # Create df of lag times
  lag_hr <- as.numeric(difftime(max_time, casc_time_max, units = "hours"))
  lags   <- data.frame(sensor = sensor[2:7], max_time, lag_hr, 
                       date = as.Date(max_time))
  
  return(lags)
  print(lags)
}

lag_1 <- gw_lags("2015-03-01", "2015-05-31")
lag_2 <- gw_lags("2014-11-01", "2014-12-31")
lag_3 <- gw_lags("2014-05-01", "2014-05-31")
lag_4 <- gw_lags("2014-05-01", "2014-05-10")
lag_5 <- gw_lags("2014-04-01", "2014-04-15")
lag_6 <- gw_lags("2014-03-01", "2014-03-31")
lag_7 <- gw_lags("2014-06-01", "2014-06-21")
lag_8 <- gw_lags("2014-08-14", "2014-08-20")

lag_9  <- gw_lags("2013-04-01", "2013-04-30"); lag_9[1, "lag_hr"] <- NA
lag_10 <- gw_lags("2013-05-01", "2013-05-31")
lag_11 <- gw_lags("2013-06-19", "2013-06-30")
# lag_12 <- gw_lags("2013-07-01", "2013-07-31")

# All data from sensor 5 should be removed, looks like this sensor is being affected by diel evaporation trends
lag_13 <- gw_lags("2016-05-15", "2016-05-22"); lag_13[2, "lag_hr"] <- NA
lag_14 <- gw_lags("2016-06-01", "2016-06-30"); lag_14[2, "lag_hr"] <- NA
lag_15 <- gw_lags("2016-09-01", "2016-09-30"); lag_15[2, "lag_hr"] <- NA
lag_16 <- gw_lags("2016-10-01", "2016-10-13"); lag_16[2, "lag_hr"] <- NA
lag_17 <- gw_lags("2016-10-26", "2016-11-15"); lag_17[2, "lag_hr"] <- NA

lag_18 <- gw_lags("2017-03-01", "2017-03-18")
lag_19 <- gw_lags("2017-05-01", "2017-05-10")
lag_20 <- gw_lags("2017-05-10", "2017-05-19")
lag_21 <- gw_lags("2017-05-20", "2017-05-27")
lag_22 <- gw_lags("2017-06-01", "2017-06-30")
lag_23 <- gw_lags("2017-06-13", "2017-06-16")
lag_24 <- gw_lags("2017-06-16", "2017-06-25")
lag_25 <- gw_lags("2017-07-01", "2017-07-31")

lag_25 <- gw_lags("2018-04-20", "2018-05-15")
lag_26 <- gw_lags("2018-04-25", "2018-05-02")
lag_27 <- gw_lags("2018-11-01", "2018-11-30"); lag_27[6, "lag_hr"] <- NA

lags <- rbind(lag_1,lag_2,lag_3,lag_4,lag_5,lag_6,lag_7,lag_8,lag_10,
              lag_11,lag_13,lag_14,lag_15,lag_16,lag_17,lag_18,lag_19,
              lag_20,lag_21,lag_22,lag_23,lag_24,lag_25,lag_26,lag_27)

lags <- merge(lags, rank, by = "sensor")

# Clearly, there are a number of cases where the GW wells that are furthest from the main stem are experiencing an increase in water level sooner than the main stem. This could be due to runoff from the adjacent slope to the floodplain or groundwater input from a source other than the main stem that is sensivitive to precipitation or snow melt.

mean_lag <- lags %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

# Boxplot of lag times for each well

png("./Figures/Flood Figures/Well Lag Time Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mar = c(4,6,2,1))
boxplot(lag_hr ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Lag from CASC in Peak Water Level (hr)", line = 2)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
title(main = "All Floods")
dev.off()

# Two boxplots broken up by cases where wells HA08 and 07 have negative lags
length(lags$lag_hr[lags$sensor == 3 & lags$lag_hr <0])
length(lags$lag_hr[lags$sensor == 1 & lags$lag_hr <0])

# Lags excluding less than zero lags from HA08 (sensor 1)
dates            <- lags$date[which(lags$sensor == 3 & lags$lag_hr < 0 |
                                    lags$sensor == 1 & lags$lag_hr < 0)]
lags_1_less_zero <- lags[lags$date %in% dates,]
lags_wo_1zero    <- lags[!(lags$date %in% dates),]

png("./Figures/Flood Figures/Well Lag Time Boxplot Biplot.png", 
           units = "in", res = 150, width = 5.5, height = 4)
par(oma = c(4,6,1.5,0), mar = c(0,0,1.5,1), mfrow = c(1,2))
boxplot(lag_hr ~ rank, data = lags_1_less_zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
# title(xlab = "Lag from CASC in Peak Water Level (hr)", line = 2)
title(ylab = "Rank Distance from Main Stem       ", outer = TRUE, line = 4.5)
title(main = " < 0", cex.main = 1, font = 1)

boxplot(lag_hr ~ rank, data = lags_wo_1zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
# axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'), las=1, adj=0)
title(sub = "Lag from CASC in Peak Water Level (hr)", outer = TRUE, line = 2)
title(main = "Floods where HA07 or HA08 Lag Time", outer = TRUE, 
      cex.main = 1, font = 1, line = 0)
title(main = " > 0", cex.main = 1, font = 1)
dev.off()

mean_lag <- lags_1_less_zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

mean_lag <- lags_wo_1zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

```


Conductivity lags


```{r}
library(dplyr)

cond <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
cond <- cond[-which(cond$cond == -999 | cond$cond_flag == 1 | cond$cond_flag == 2),]
level <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2),]

# Convert datetime to POSIX variable type
cond$datetime <- as.POSIXct(cond$datetime, tz = "MST")
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

cond  <- merge(cond, rank, by.x = "sensor_number", by.y = "sensor")
level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
cond <- cond[cond$sensor_number %in% sensor,]# Subset the water level data to only 
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
cond <- split(cond, f = as.factor(cond$rank))
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(cond) <- sensor
names(level) <- sensor

# For testing functions below
start_date <- "2015-03-25"
end_date   <- "2015-04-25"

# Function to find the time difference between peak water level in the main stem and max change in conductivity of the groundwater wells
gw_lags <- function(start_date, end_date){
  # Define period of time containing flood
  start <- as.POSIXct(start_date, tz = "MST")
  end   <- as.POSIXct(end_date, tz = "MST")

  png(paste0("./Figures/Flood Figures/GW Level Cond_", start_date,"_", end_date, ".png"), units = "in", width = 6, height = 12, res = 100, bg = "transparent")
  par(mfrow = c(7,1), oma = c(1,1,1,0), mar = c(1,5,0,2))
  
  tmp <- level[[1]][level[[1]]$datetime >= start & level[[1]]$datetime <= end,]
  casc_max_lev  <- max(na.omit(tmp$level_m))
  casc_time_max <- tmp[match(casc_max_lev, tmp$level_m), "datetime"]
  
  tmp <- cond[[1]][cond[[1]]$datetime >= start & cond[[1]]$datetime <= end,]
  min_cond  <- min(na.omit(tmp$cond))
  min_cond_time <- tmp[match(min_cond, tmp$cond), "datetime"]
  
  lapply(seq_along(cond), function(i){
    c.tmp <- cond[[i]][cond[[i]]$datetime >= start & cond[[i]]$datetime <= end,]
    l.tmp <- level[[i]][level[[i]]$datetime >= start & level[[i]]$datetime <= end,]
    plot(c.tmp$datetime, c.tmp$cond, xlab = " ", ylab = "Cond (mS)", 
         xlim = c(start, end), xaxs = 'i',
         cex.lab = 2, cex.axis = 2, pch = 19, xaxt = 'n')
    par(new = T)
    plot(l.tmp$datetime, l.tmp$level_m, xlab = " ", ylab = " ", col = "grey",
         xlim = c(start, end), xaxs = 'i', pch = 19, xaxt = 'n', yaxt = 'n')
    abline(v = casc_time_max, lwd = 2, col = "red")
    abline(v = min_cond_time, lwd = 2, col = "blue")
    mtext(paste(temp[1,1], sep = '_'), side = 4,
          line = 1, cex = 1.5)
    box(lwd = 2)
    })
  
  breaks <- pretty(c(0,as.numeric(difftime(end, start))), n = 3) * 60 * 60 * 24
  axis(side = 1, at = c(start + breaks), 
       labels = format(start + breaks, "%m-%d"), cex.axis = 2)
  # x.coord <- start + as.numeric(difftime(end, start)) / 2 * 60 * 60 * 24
  # legend(xcoord, , pch = 19, col = c("black", "grey"),
  #        legend = c("Cond", "Level"), horiz = TRUE, bty = 'n')
  
  dev.off()
}

lag_1 <- gw_lags("2015-03-25", "2015-04-14")
lag_2 <- gw_lags("2014-11-21", "2014-12-31")
lag_3 <- gw_lags("2014-05-01", "2014-05-10")
lag_5 <- gw_lags("2014-04-01", "2014-04-15")
lag_6 <- gw_lags("2014-03-01", "2014-03-31")
lag_7 <- gw_lags("2014-06-01", "2014-06-21")
lag_8 <- gw_lags("2014-08-14", "2014-08-20")

lag_9  <- gw_lags("2013-04-01", "2013-04-30"); lag_9[1, "lag_hr"] <- NA
lag_10 <- gw_lags("2013-05-01", "2013-05-31")
lag_11 <- gw_lags("2013-06-19", "2013-06-30")
# lag_12 <- gw_lags("2013-07-01", "2013-07-31")

# All data from sensor 5 should be removed, looks like this sensor is being affected by diel evaporation trends
lag_13 <- gw_lags("2016-05-15", "2016-05-22"); lag_13[2, "lag_hr"] <- NA
lag_14 <- gw_lags("2016-06-01", "2016-06-30"); lag_14[2, "lag_hr"] <- NA
lag_15 <- gw_lags("2016-09-01", "2016-09-30"); lag_15[2, "lag_hr"] <- NA
lag_16 <- gw_lags("2016-10-01", "2016-10-13"); lag_16[2, "lag_hr"] <- NA
lag_17 <- gw_lags("2016-10-26", "2016-11-15"); lag_17[2, "lag_hr"] <- NA

lag_18 <- gw_lags("2017-03-01", "2017-03-18")
lag_19 <- gw_lags("2017-05-01", "2017-05-10")
lag_20 <- gw_lags("2017-05-10", "2017-05-19")
lag_21 <- gw_lags("2017-05-20", "2017-05-27")
lag_22 <- gw_lags("2017-06-01", "2017-06-30")
lag_23 <- gw_lags("2017-06-13", "2017-06-16")
lag_24 <- gw_lags("2017-06-16", "2017-06-25")
lag_25 <- gw_lags("2017-07-01", "2017-07-31")

lag_25 <- gw_lags("2018-04-20", "2018-05-15")
lag_26 <- gw_lags("2018-04-25", "2018-05-02")
lag_27 <- gw_lags("2018-11-01", "2018-11-30"); lag_27[6, "lag_hr"] <- NA

lags <- rbind(lag_1,lag_2,lag_3,lag_4,lag_5,lag_6,lag_7,lag_8,lag_10,
              lag_11,lag_13,lag_14,lag_15,lag_16,lag_17,lag_18,lag_19,
              lag_20,lag_21,lag_22,lag_23,lag_24,lag_25,lag_26,lag_27)

lags <- merge(lags, rank, by = "sensor")

# Clearly, there are a number of cases where the GW wells that are furthest from the main stem are experiencing an increase in water level sooner than the main stem. This could be due to runoff from the adjacent slope to the floodplain or groundwater input from a source other than the main stem that is sensivitive to precipitation or snow melt.

mean_lag <- lags %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

```

