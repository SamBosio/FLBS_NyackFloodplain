---
title: "Nyack_Floodplain_Flood_Dynamics"
author: "Amalia Handler"
date: "1/24/2020"
output: 
  html_document: 
    keep_md: yes
editor_options: 
  chunk_output_type: console
---

This script is used to investigate the influence of Middle Fork of the Flathead River floods on the Nyack Floodplain. The data (temperature, dissolved oxygen, conductivity, and water level) include six groundwater wells and three surface water wells.

Note that the data used here has been QAQC'ed through removal of bad data associated with sensor error and servicing using the script titled "Nyack_Floodplain_Water_QAQC.Rmd" available on Amalia Handler's GitHub repository amaliahandler/FLBS_NyackFloodplain.


```{r}
# Load packages

# Load data
options(stringsAsFactors = FALSE)
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

```


Visualize the how floods on the mainstem influence the groundwater wells.


```{r}
# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
level <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2),]

# Convert datetime to POSIX variable type
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(level) <- sensor

# Find the latest start date for each sensor
min_dates <- lapply(level, function(x){min(x$datetime)})

latest_start <- max(do.call("c", min_dates))

# Subset each sensor such that all have the same start datetime
level <- lapply(level, function(x){x[x$datetime >= latest_start,]})

# Make figure of entire time series
y_label   <- "Level (m)"

png("./Figures/Flood Figures/GW Level by Rank.png", units = "in", 
    width = 8, height = 12, res = 100, bg = "transparent")

par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))

lapply(level, function(x){
  plot(x$datetime, x$level_m, xlab = " ", ylab = y_label, 
       cex.lab = 2, cex.axis = 2, pch = 20)

  title(paste(x[1,2], x[1,1], sep = '_'), 
        line = 0.5, cex.main = 2)
  
  box(lwd = 2)
  })

dev.off()

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Level (m)"
  
  # Standardize the y axis limits based on the CASC sensor
  # Find the max and min of the water level data for CASC
  temp <- level$`6`[level$`6`$datetime >= start & level$`6`$datetime <= end,]
  max_level <- max(temp$level_m)
  min_level <- min(temp$level_m)
  casc_diff <- (max_level - min_level) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW Level by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(level, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_level <- max(temp$level_m)
    min_level <- min(temp$level_m)
    mid_point <- (max_level - min_level) / 2
    ylim_up   <- (min_level + mid_point) + casc_diff
    ylim_lo   <- (min_level + mid_point) - casc_diff
    
    plot(temp$datetime, temp$level_m, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}


```


Make a set of figures for the DO temperature sensor


```{r}
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)

# Temperature flood data from the DO sensor
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
do <- do[-which(do$do_temp == -999 | do$do_temp_flag == 1 | do$do_temp_flag == 2),]

# Convert datetime to POSIX variable type
do$datetime <- as.POSIXct(do$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

do  <- merge(do, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
do <- do[do$sensor_number %in% sensor,]

# Break the df into a list based on rank
do <- split(do, f = as.factor(do$rank))

# Make the names the sensor number
names(do) <- sensor

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Temp (C)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(do, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$do_temp) - min(temp$do_temp)
                })
  
  max_diff  <- max(dat_range) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW Temp by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(do, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_temp <- max(temp$do_temp)
    min_temp <- min(temp$do_temp)
    mid_point <- (max_temp - min_temp) / 2
    ylim_up   <- (min_temp + mid_point) + max_diff
    ylim_lo   <- (min_temp + mid_point) - max_diff
    
    plot(temp$datetime, temp$do_temp, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```




Make a set of figures for the DO saturation sensor




```{r}
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)

# DO saturation flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
do <- do[-which(do$do_sat == -999 | do$do_sat_flag == 1 | do$do_sat_flag == 2),]

# Convert datetime to POSIX variable type
do$datetime <- as.POSIXct(do$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

do  <- merge(do, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
do <- do[do$sensor_number %in% sensor,]

# Break the df into a list based on rank
do <- split(do, f = as.factor(do$rank))

# Make the names the sensor number
names(do) <- sensor

# Testing
i <- 2013
x <- do$`6`

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "DO Sat (%)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(do, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$do_sat) - min(temp$do_sat)
                })
  
  max_diff  <- max(dat_range) / 2
  
  png(paste0("./Figures/Flood Figures/", year,"_GW DO Sat by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(do, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_sat   <- max(temp$do_sat)
    min_sat   <- min(temp$do_sat)
    mid_point <- (max_sat - min_sat) / 2
    ylim_up   <- (min_sat + mid_point) + max_diff
    ylim_lo   <- (min_sat + mid_point) - max_diff
    
    plot(temp$datetime, temp$do_sat, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```


Make a set of figures for the conductivity


```{r}
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)

# Conductivity flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
cond <- cond[-which(cond$cond == -999 | cond$cond_flag == 1 | cond$cond_flag == 2),]

# Convert datetime to POSIX variable type
cond$datetime <- as.POSIXct(cond$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

cond   <- merge(cond, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
cond <- cond[cond$sensor_number %in% sensor,]

# Break the df into a list based on rank
cond <- split(cond, f = as.factor(cond$rank))

# Make the names the sensor number
names(cond) <- sensor

# Testing
i <- 2013
x <- cond$`6`

# Make figure of year to year data
for(i in 2013:2019){
  year      <- as.character(i)
  start     <- as.POSIXct(paste0(year, "-01-01"))
  end       <- as.POSIXct(paste0(year, "-12-31"))
  y_label   <- "Cond (mS)"
  
  # Standardize the y axis limits based on the sensor with the largest range of values
  dat_range <- sapply(cond, function(x){
                  temp <- x[x$datetime >= start & x$datetime <= end,]
                  dat_range <- max(temp$cond) - min(temp$cond)
                })
  
  max_diff  <- max(dat_range) / 2

  png(paste0("./Figures/Flood Figures/", year,"_GW Cond by Rank.png"), 
      units = "in", width = 8, height = 12, res = 100, bg = "transparent")
  
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  
  lapply(cond, function(x){
    temp      <- x[x$datetime >= start & x$datetime <= end,]
    max_cond  <- max(temp$cond)
    min_cond  <- min(temp$cond)
    mid_point <- (max_cond - min_cond) / 2
    ylim_up   <- (min_cond + mid_point) + max_diff
    ylim_lo   <- (min_cond + mid_point) - max_diff
    
    plot(temp$datetime, temp$cond, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20)
  
    title(paste(x[1,2], x[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
    })
  
  dev.off()
  print(i)
}

```


Visuals of some key representative wells that show the influence of floods
CASC main channel
HA02_9, GW sensor closest to the main channel
HA07_3, GW sensor farthest from the main channel

Show time series for 2014 and 2013-2018 for water level, temperature, DO % saturation, and conductivity


```{r}
cond  <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
do    <- read.csv('./Data/Nyack_do_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Remove bad and questionable data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)
cond    <- cond[-which(cond$cond == -999 | cond$cond_flag == 1 | 
                         cond$cond_flag == 2),]
do_sat  <- do[-which(do$do_sat == -999 | do$do_sat_flag == 1 | 
                       do$do_sat_flag == 2),]
level   <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | 
                          level$level_m_flag == 2),]
do_temp <- do[-which(do$do_temp == -999 | 
                       do$do_temp_flag == 1 | do$do_temp_flag == 2),]

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
rank   <- data.frame(sensor = c(6,9,3), rank = c(1:3))

merge_rank <- function(x){
  merge(x, rank, by.x = "sensor_number", by.y = "sensor")
}

cond    <- merge_rank(cond)
do_sat  <- merge_rank(do_sat)
do_temp <- merge_rank(do_temp)
level   <- merge_rank(level)

# Convert datetime to POSIX variable type
time_to_POSIX <- function(x){
  as.POSIXct(x$datetime, tz = "MST")
}

cond$datetime    <- time_to_POSIX(cond)
do_sat$datetime  <- time_to_POSIX(do_sat)
level$datetime   <- time_to_POSIX(level)
do_temp$datetime <- time_to_POSIX(do_temp)

# For ease of looping, rename the key variable for visuals "value"
colnames(do_temp)[5] <- "value"
colnames(do_sat)[6]  <- "value"
colnames(level)[4]   <- "value"
colnames(cond)[4]    <- "value"

# Break the df into a list based on rank
list_cenversion <- function(x){
  split(x, f = as.factor(x$rank))
}

cond    <- list_cenversion(cond)
do_sat  <- list_cenversion(do_sat)
do_temp <- list_cenversion(do_temp)
level   <- list_cenversion(level)

# Make figure of 2014 data
# Level over temp on the left
# DO sat over temp on the right
year      <- 2014
start     <- as.POSIXct(paste0(year, "-01-01"))
end       <- as.POSIXct(paste0(year, "-12-31"))

# Standardize the y axis limits based on the sensor with the largest range of values
find_max_diff <- function(list){
  dat_range <- sapply(list, function(x){
                temp <- x[x$datetime >= start & x$datetime <= end,]
                dat_range <- max(temp$value) - min(temp$value)
              })
  max_diff  <- max(dat_range) / 2
}

max_diff_level <- find_max_diff(level)
max_diff_temp  <- find_max_diff(do_temp)
max_diff_sat   <- find_max_diff(do_sat)
max_diff_cond  <- find_max_diff(cond)

# Draw order (left to right, then up to down)
# Water level 6, Cond 6
# water level 9, cond 9
# Water level 3, cond 3
# Temp 6, DO sat 6
# Temp 9, DO sat 9
# Temp 3, DO sat 3
draw_order <- data.frame(df = c(rep(c("level", "cond"), 3), 
                                rep(c("do_temp", "do_sat"), 3)),
                         sensor = c(rep(c(6,6,9,9,3,3), 2)),
                         rank = c(rep(c(1,1,2,2,3,3), 2)))

df <- tmp
max_diff <- max_diff_level
y_label <- "Level (m)"

# Function to draw each plot
plot_draw <- function(df, max_diff, y_label, color){
    temp      <- df[df$datetime >= start & df$datetime <= end,]
    max_val   <- max(temp$value)
    min_val   <- min(temp$value)
    mid_point <- (max_val - min_val) / 2
    ylim_up   <- (min_val + mid_point) + max_diff
    ylim_lo   <- (min_val + mid_point) - max_diff
    
    plot(temp$datetime, temp$value, 
         xlab = " ", ylab = y_label, xaxs = 'i', yaxs = 'i',
         ylim = c(ylim_lo, ylim_up),
         xlim = c(start, end),
         cex.lab = 2, cex.axis = 2, pch = 20, col = color)
  
    title(paste(temp[1,2], temp[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    
    box(lwd = 2)
}

# Create the massive, 6 by 2 plot
png(paste0("./Figures/Flood Figures/", year,"_GW Comparison All Variables.png"), 
    units = "in", width = 14, height = 12, res = 1000, bg = "transparent")

par(mfrow = c(6,2), oma = c(2,2,1,1), mar = c(3,5,2,0))

# Loop to create the plot
for(i in 1:nrow(draw_order)){
  if(draw_order$df[i] == "level"){
    tmp <- level[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_level, "Level (m)", "black")
    
  } else if(draw_order$df[i] == "cond"){
    tmp <- cond[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_cond, "Cond (mS)", "darkgrey")
    
  } else if(draw_order$df[i] == "do_temp"){
    tmp <- do_temp[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_temp, "Temp (C)", "darkblue")
    
  } else{
    tmp <- do_sat[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_sat, "DO % Sat", "darkslategrey")
  }
  print(draw_order[i,])
}

dev.off()





# Same type of plot, but for the period between 2013 and 2018
start     <- as.POSIXct("2013-01-01")
end       <- as.POSIXct("2018-12-31")

max_diff_level <- find_max_diff(level)
max_diff_temp  <- find_max_diff(do_temp)
max_diff_sat   <- find_max_diff(do_sat)
max_diff_cond  <- find_max_diff(cond)

# Create the massive, 6 by 2 plot
png(paste0("./Figures/Flood Figures/2013-2018 GW Comparison All Variables.png"), 
    units = "in", width = 18, height = 12, res = 1000, bg = "transparent")

par(mfrow = c(6,2), oma = c(2,2,1,1), mar = c(3,5,2,0))

# Loop to create the plot
for(i in 1:nrow(draw_order)){
  if(draw_order$df[i] == "level"){
    tmp <- level[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_level, "Level (m)", "black")
    
  } else if(draw_order$df[i] == "cond"){
    tmp <- cond[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_cond, "Cond (mS)", "darkgrey")
    
  } else if(draw_order$df[i] == "do_temp"){
    tmp <- do_temp[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_temp, "Temp (C)", "darkblue")
    
  } else{
    tmp <- do_sat[[draw_order$rank[i]]]
    plot_draw(tmp, max_diff_sat, "DO % Sat", "darkslategrey")
  }
  print(draw_order[i,])
}

dev.off()



```



Analyze the lag in water level change due to floods across wells


```{r}
library(dplyr)

level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Remove questionable and bad data
level <- level[-which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2),]

# Convert datetime to POSIX variable type
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(level) <- sensor

# For testing functions below
start_date <- "2015-03-25"
end_date   <- "2013-04-10"

# Function to standardize the size of the y axis range in figures
find_max_diff <- function(list){
  dat_range <- sapply(list, function(x){
                temp <- x[x$datetime >= start & x$datetime <= end,]
                dat_range <- max(temp$level_m) - min(temp$level_m)
              })
  max_diff  <- max(dat_range) / 2
}


# Function to find the time difference between peak water level in the main stem and the groundwater wells
gw_lags <- function(start_date, end_date){
  # Define period of time containing flood
  start <- as.POSIXct(start_date)
  end   <- as.POSIXct(end_date)
  
  # Get the time of peak water level at CASC
  temp <- level$`6`[level$`6`$datetime >= start & level$`6`$datetime <= end,]
  casc_max_lev <- max(na.omit(temp$level_m))
  casc_time_max <- temp[match(casc_max_lev, temp$level_m), "datetime"]
  
  # Plot the GW level relative to CASC
  max_diff <- find_max_diff(level)
  
  png(paste0("./Figures/Flood Figures/GW Level_", start_date,"_", end_date, "_V2.png"), units = "in", width = 12, height = 12, res = 100, bg = "transparent")
  par(mfrow = c(7,1), oma = c(2,2,1,1), mar = c(3,5,2,0))
  lapply(level, function(x){
      temp      <- x[x$datetime >= start & x$datetime <= end,]
      max_val   <- max(temp$level_m)
      min_val   <- min(temp$level_m)
      mid_point <- (max_val - min_val) / 2
      ylim_up   <- (min_val + mid_point) + max_diff
      ylim_lo   <- (min_val + mid_point) - max_diff
    plot(temp$datetime, temp$level_m, xlab = " ", ylab = "Level (m)", 
         xlim = c(start, end), xaxs = 'i', yaxs = 'i',
         cex.lab = 2, cex.axis = 2, pch = 20)
    abline(v = casc_time_max, lwd = 3, col = "blue")
    title(paste(temp[1,2], temp[1,1], sep = '_'), 
          line = 0.5, cex.main = 2)
    box(lwd = 2)
    })
  dev.off()
  
  # Find the corresponding time of max level in GW wells
  # Add the difference between the baseline and the max
  for(i in 1:7){
    temp <- level[[i]][level[[i]]$datetime >= start & level[[i]]$datetime <= end,]
    ini_lev <- temp$level_m[1]
    max_lev <- max(na.omit(temp$level_m))
    chg     <- max_lev - ini_lev
    max_t <- temp[match(max_lev, temp$level_m), "datetime"]
    ifelse(i == 1, max_time <- max_t, max_time[i] <- max_t)
    ifelse(i == 1, chg_lev <- chg, chg_lev[i] <- chg)
  }
  
  # Create df of lag times
  lag_hr <- as.numeric(difftime(max_time, casc_time_max, units = "hours"))
  lags   <- data.frame(sensor = sensor[1:7], max_time, lag_hr, 
                       date = as.Date(max_time), level_chg = chg_lev)
  
  return(lags)
  print(lags)
}

lag_1 <- gw_lags("2015-03-01", "2015-05-31")
lag_2 <- gw_lags("2014-11-01", "2014-12-31")
lag_3 <- gw_lags("2014-05-01", "2014-05-31")
lag_4 <- gw_lags("2014-05-01", "2014-05-10")
lag_5 <- gw_lags("2014-04-01", "2014-04-15")
lag_6 <- gw_lags("2014-03-01", "2014-03-31")
lag_7 <- gw_lags("2014-06-01", "2014-06-21")
lag_8 <- gw_lags("2014-08-14", "2014-08-20")

lag_9  <- gw_lags("2013-04-01", "2013-04-30"); lag_9[1, "lag_hr"] <- NA
lag_10 <- gw_lags("2013-05-01", "2013-05-31")
lag_11 <- gw_lags("2013-06-19", "2013-06-30")
# lag_12 <- gw_lags("2013-07-01", "2013-07-31")

# All data from sensor 5 should be removed, looks like this sensor is being affected by diel evaporation trends
lag_13 <- gw_lags("2016-05-15", "2016-05-22"); lag_13[2, "lag_hr"] <- NA
lag_14 <- gw_lags("2016-06-01", "2016-06-30"); lag_14[2, "lag_hr"] <- NA
lag_15 <- gw_lags("2016-09-01", "2016-09-30"); lag_15[2, "lag_hr"] <- NA
lag_16 <- gw_lags("2016-10-01", "2016-10-13"); lag_16[2, "lag_hr"] <- NA
lag_17 <- gw_lags("2016-10-26", "2016-11-15"); lag_17[2, "lag_hr"] <- NA

lag_18 <- gw_lags("2017-03-01", "2017-03-18")
lag_19 <- gw_lags("2017-05-01", "2017-05-10")
lag_20 <- gw_lags("2017-05-10", "2017-05-19")
lag_21 <- gw_lags("2017-05-20", "2017-05-27")
lag_22 <- gw_lags("2017-06-01", "2017-06-30")
lag_23 <- gw_lags("2017-06-13", "2017-06-16")
lag_24 <- gw_lags("2017-06-16", "2017-06-25")
lag_25 <- gw_lags("2017-07-01", "2017-07-31")

lag_25 <- gw_lags("2018-04-20", "2018-05-15")
lag_26 <- gw_lags("2018-04-25", "2018-05-02")
lag_27 <- gw_lags("2018-11-01", "2018-11-30"); lag_27[6, "lag_hr"] <- NA

lags <- rbind(lag_1,lag_2,lag_3,lag_4,lag_5,lag_6,lag_7,lag_8,lag_10,
              lag_11,lag_13,lag_14,lag_15,lag_16,lag_17,lag_18,lag_19,
              lag_20,lag_21,lag_22,lag_23,lag_24,lag_25,lag_26,lag_27)

lags <- merge(lags, rank, by = "sensor")

# Clearly, there are a number of cases where the GW wells that are furthest from the main stem are experiencing an increase in water level sooner than the main stem. This could be due to runoff from the adjacent slope to the floodplain or groundwater input from a source other than the main stem that is sensivitive to precipitation or snow melt.

mean_lag <- lags %>%
  group_by(rank, sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)),
            level_chg = mean(na.omit(level_chg)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

# Boxplot of lag times for each well

png("./Figures/Flood Figures/Well Lag Time Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mar = c(4,6,2,1))
boxplot(lag_hr ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Lag from CASC in Peak Water Level (hr)", line = 2)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
title(main = "All Floods")
dev.off()

# Two boxplots broken up by cases where wells HA08 and 07 have negative lags
length(lags$lag_hr[lags$sensor == 3 & lags$lag_hr <0])
length(lags$lag_hr[lags$sensor == 1 & lags$lag_hr <0])

# Lags excluding less than zero lags from HA08 (sensor 1)
dates            <- lags$date[which(lags$sensor == 3 & lags$lag_hr < 0 |
                                    lags$sensor == 1 & lags$lag_hr < 0)]
lags_1_less_zero <- lags[lags$date %in% dates,]
lags_wo_1zero    <- lags[!(lags$date %in% dates),]

png("./Figures/Flood Figures/Well Lag Time Boxplot Biplot.png", 
           units = "in", res = 150, width = 5.5, height = 4)
par(oma = c(4,6,1.5,0), mar = c(0,0,1.5,1), mfrow = c(1,2))
boxplot(lag_hr ~ rank, data = lags_1_less_zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
# title(xlab = "Lag from CASC in Peak Water Level (hr)", line = 2)
title(ylab = "Rank Distance from Main Stem       ", outer = TRUE, line = 4.5)
title(main = " < 0", cex.main = 1, font = 1)

boxplot(lag_hr ~ rank, data = lags_wo_1zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
# axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'), las=1, adj=0)
title(sub = "Lag from CASC in Peak Water Level (hr)", outer = TRUE, line = 2)
title(main = "Floods where HA07 or HA08 Lag Time", outer = TRUE, 
      cex.main = 1, font = 1, line = 0)
title(main = " > 0", cex.main = 1, font = 1)
dev.off()

png("./Figures/Flood Figures/Well Water Level Change Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mfrow = c(1,1), mar = c(4,6,1,1), oma = c(0,0,0,0))
boxplot(level_chg ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(7.5,0.5), yaxt = "n")
axis(2, at=c(1:7), labels=c('CASC','1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Difference between pre-flood and peak water level (m)", line = 2)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
dev.off()

mean_lag <- lags_1_less_zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

mean_lag <- lags_wo_1zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

```


Conductivity lags


```{r}
library(dplyr)

cond <- read.csv('./Data/Nyack_cond_cleaned.csv', header = TRUE)
level <- read.csv('./Data/Nyack_level_cleaned.csv', header = TRUE)

# Water level flood data
# Bad data: value = -999
# Questionable data flags: 1 (questionable), 2 (silt in well)

# Replace questionable and bad data with NA values
cond$cond[which(cond$cond == -999 | cond$cond_flag == 1 | cond$cond_flag == 2)] <- NA
level$level_m[which(level$level_m == -999 | level$level_m_flag == 1 | level$level_m_flag == 2)] <- NA

# Convert datetime to POSIX variable type
cond$datetime <- as.POSIXct(cond$datetime, tz = "MST")
level$datetime <- as.POSIXct(level$datetime, tz = "MST")

# Rank groundwater wells by distance from the Middle Fork of the Flathead River
# The water level on the Middle Fork (CASC sensor) receives a rank of 1
sensor <- c(6,9,5,7,4,1,3)
rank   <- c(1:7)
rank   <- data.frame(sensor, rank)

cond  <- merge(cond, rank, by.x = "sensor_number", by.y = "sensor")
level  <- merge(level, rank, by.x = "sensor_number", by.y = "sensor")

# Subset the water level data to only include the sensors for this analysis
cond <- cond[cond$sensor_number %in% sensor,]# Subset the water level data to only 
level <- level[level$sensor_number %in% sensor,]

# Break the df into a list based on rank
cond <- split(cond, f = as.factor(cond$rank))
level <- split(level, f = as.factor(level$rank))

# Make the names the sensor number
names(cond) <- sensor
names(level) <- sensor

# So much data that correlation exists across all lags
# ccf(x, y, exclude NAs, maximum number of lags)
# Plot is the lag time in x relative to y
# Horizontal lines are 95% CI for correlation
ccf(level[[2]]$level_m, level[[1]]$level_m, na.action = na.exclude, lag.max = 100)

# Do this for periods that had floods

# Function to find the time difference between peak water level in the main stem and the groundwater wells

# Testing
start_date      <- "2014-11-20"
end_date        <- "2014-12-15"
comparison_well <- 2
nlag            <- 50

# Revise the function to perform the cross correlation for pairwise comparisons between the main stem and each well
# Find the max correlation coefficient
# Find the lag times that match that max correlation
# Find the median of those lag times
# compile a df that has the well information and the median lag time

# Need to look for cross correlation for water level and conductivity change within the same well. Correlation present = new flood water source in well (??) no correlation present = same source water getting "pushed" faster through the floodplain..

# These case be combined into a df ad visualized

cond_lags <- function(start_date, end_date){
  # Define period of time containing flood
  start <- as.POSIXct(start_date)
  end   <- as.POSIXct(end_date)
  nlag  <- 50

  # Subset for the dates of interest
  l.subs <- lapply(level, function(x){
    x[x$datetime >= start & x$datetime <= end,]
  })
  c.subs <- lapply(cond, function(x){
    x[x$datetime >= start & x$datetime <= end,]
  })
  
  # Perform the pairwise comparisons
  l.ccfs <- lapply(l.subs, function(x){
    ccf(x$level_m, l.subs[[1]]$level_m, na.action = na.exclude, lag.max = nlag)
  })
  # For conductivity, perform cross correlation with main stem water level
  c.ccfs <- lapply(c.subs, function(x){
    ccf(x$cond, l.subs[[1]]$level_m, na.action = na.exclude, lag.max = nlag)
  })
  # For conductivity, perform cross correlation with water level in same well
  w.ccfs <- lapply(seq_along(c.subs), function(i){
    ccf(c.subs[[i]]$cond, l.subs[[i]]$level_m, na.action = na.exclude, lag.max = nlag)
  })
  
  # Find the max correlation coefficient
  l.max.cc <- lapply(l.ccfs, function(x){
    ifelse(max(x$acf) > abs(min(x$acf)), max(x$acf), min(x$acf))
  })
  c.max.cc <- lapply(c.ccfs, function(x){
    ifelse(max(x$acf) > abs(min(x$acf)), max(x$acf), min(x$acf))
  })
  w.max.cc <- lapply(w.ccfs, function(x){
    ifelse(max(x$acf) > abs(min(x$acf)), max(x$acf), min(x$acf))
  })
  
  # Find the lags that match that max correlation
  l.n.lag <- lapply(seq_along(l.max.cc), function(i){
    l.ccfs[[i]]$lag[round(l.ccfs[[i]]$acf, 3) == round(l.max.cc[[i]], 3)]
  })
  c.n.lag <- lapply(seq_along(c.max.cc), function(i){
    c.ccfs[[i]]$lag[round(c.ccfs[[i]]$acf, 3) == round(c.max.cc[[i]], 3)]
  })
  w.n.lag <- lapply(seq_along(w.max.cc), function(i){
    c.ccfs[[i]]$lag[round(w.ccfs[[i]]$acf, 3) == round(w.max.cc[[i]], 3)]
  })
  
  # Find the median value of the lag
  # If the lag is more than 24hrs, replace with NA
  l.med.lag <- sapply(l.n.lag, function(x){
    ifelse(abs(median(x)) <= 24, median(x), NA)
  })
  c.med.lag <- sapply(c.n.lag, function(x){
    ifelse(abs(median(x)) <= 24, median(x), NA)
  })
  c.med.lag <- sapply(w.n.lag, function(x){
    ifelse(abs(median(x)) <= 24, median(x), NA)
  })
  
  # Remove the autocorrelation value for the main stem
  # Create df with sensor #
  lag <- data.frame(sensor = sensor[2:7], lag_level = l.med.lag[2:7], 
                    lag_cond = c.med.lag[2:7], lag_cond_well = c.med.lag[2:7]) 
  return(lag)
}


# lag_1 <- gw_lags("2015-03-01", "2015-05-31", 5, 24)
# lag_2 <- gw_lags("2014-11-20", "2014-12-15", 7, 24)
# lag_3 <- gw_lags("2014-05-20", "2014-05-31", 2, 24)
# lag_4 <- gw_lags("2014-05-01", "2014-05-10", 2, 24)
# lag_5 <- gw_lags("2014-04-01", "2014-04-15", 2, 24)
# lag_6 <- gw_lags("2014-03-07", "2014-03-16", 2, 24)
# lag_7 <- gw_lags("2014-06-01", "2014-06-21", 2, 24)
# lag_8 <- gw_lags("2014-08-14", "2014-08-20", 2, 24)

lag_1 <- cond_lags("2015-03-01", "2015-05-31")
lag_2 <- cond_lags("2014-11-20", "2014-12-15")
lag_3 <- cond_lags("2014-05-20", "2014-05-31")
lag_4 <- cond_lags("2014-05-01", "2014-05-10")
lag_5 <- cond_lags("2014-04-01", "2014-04-15")
lag_6 <- cond_lags("2014-03-07", "2014-03-16")
lag_7 <- cond_lags("2014-06-16", "2014-06-21")
lag_8 <- cond_lags("2014-08-14", "2014-08-20")

lag_9  <- cond_lags("2013-04-03", "2013-04-12");
lag_10 <- cond_lags("2013-05-06", "2013-05-20")
lag_11 <- cond_lags("2013-06-19", "2013-06-24")

# All data from sensor 5 should be removed, looks like this sensor is being affected by diel evaporation trends
lag_13 <- cond_lags("2016-05-15", "2016-05-22"); lag_13[1, "lag_level"] <- NA
# lag_14 <- cond_lags("2016-06-01", "2016-06-30"); lag_14[2, "level_lag"] <- NA
lag_15 <- cond_lags("2016-09-16", "2016-09-23"); lag_15[1, "lag_level"] <- NA
lag_16 <- cond_lags("2016-10-01", "2016-10-13"); lag_16[1, "lag_level"] <- NA
lag_17 <- cond_lags("2016-10-31", "2016-11-05"); lag_17[1, "lag_level"] <- NA

lag_18 <- cond_lags("2017-03-01", "2017-03-18")
lag_19 <- cond_lags("2017-05-01", "2017-05-10")
lag_20 <- cond_lags("2017-05-10", "2017-05-19")
lag_21 <- cond_lags("2017-05-20", "2017-05-27")
lag_22 <- cond_lags("2017-06-01", "2017-06-05")
lag_23 <- cond_lags("2017-06-13", "2017-06-16")
lag_24 <- cond_lags("2017-06-16", "2017-06-25")
# lag_25 <- cond_lags("2017-07-01", "2017-07-31")

lag_25 <- cond_lags("2018-04-20", "2018-05-15")
lag_26 <- cond_lags("2018-04-25", "2018-05-02")
lag_27 <- cond_lags("2018-11-01", "2018-11-10"); lag_27[6, "lag_level"] <- NA



lags <- rbind(lag_1,lag_2,lag_3,lag_4,lag_5,lag_6,lag_7,lag_8,lag_10,
              lag_11,lag_13,lag_15,lag_16,lag_17,lag_18,lag_19,
              lag_20,lag_21,lag_22,lag_23,lag_24,lag_26,lag_27)

lags <- merge(lags, rank, by = "sensor")

lags$event <- rep(c(1:23), 6)

# Clearly, there are a number of cases where the GW wells that are furthest from the main stem are experiencing an increase in water level sooner than the main stem. This could be due to runoff from the adjacent slope to the floodplain or groundwater input from a source other than the main stem that is sensivitive to precipitation or snow melt.

mean_lag <- lags %>%
  group_by(rank, sensor) %>%
  summarise(lag_level = mean(na.omit(lag_level)),
            lag_cond = mean(na.omit(lag_cond)),
            lag_cond_well = median(na.omit(lag_cond_well)))

# Boxplot of lag times for each well

png("./Figures/Flood Figures/Water Level Lag Time Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mar = c(6,6,2,1))
boxplot(lag_level ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Lag (hr)", line = 2)
title(xlab = "Lag in GW water level relative to CASC water level", line = 3)
title(xlab = "Based on cross correlation coefficient", line = 4)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
title(main = "Water Level - All Floods")
dev.off()

# Conductivity relative to water level in main stem
png("./Figures/Flood Figures/Conductivity Lag Time Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mar = c(6,6,2,1))
boxplot(lag_cond ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Lag (hr)", line = 2)
title(xlab = "Lag in GW cond relative to CASC water level", line = 3)
title(xlab = "Based on cross correlation coefficient", line = 4)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
title(main = "Conductivity - All Floods")
dev.off()

# Conductivity relative to the water level in the well
png("./Figures/Flood Figures/Conductivity Lag relative to wells Time Boxplot.png", 
           units = "in", res = 150, width = 5, height = 4)
par(mar = c(6,6,2,1))
boxplot(lag_cond_well ~ rank, data = lags, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
title(xlab = "Lag (hr)", line = 2)
title(xlab = "Lag in GW cond relative to well water level", line = 3)
title(xlab = "Based on cross correlation coefficient", line = 4)
title(ylab = "Rank Distance from Main Stem", line = 4.5)
title(main = "Conductivity - All Floods")
dev.off()


# Two boxplots broken up by cases where wells HA08 and 07 have negative lags

# Lags excluding less than zero lags from HA08 (sensor 1)
events           <- lags$event[which(lags$sensor == 3 & lags$lag_level < 0 |
                                     lags$sensor == 1 & lags$lag_level < 0)]
lags_1_less_zero <- lags[lags$event %in% events,]
lags_wo_1zero    <- lags[!(lags$event %in% events),]

png("./Figures/Flood Figures/Well Lag Time Boxplot Biplot.png", 
           units = "in", res = 150, width = 5.5, height = 4)
par(oma = c(4,6,1.5,0), mar = c(0,0,1.5,1), mfrow = c(1,2))
boxplot(lag_cond ~ rank, data = lags_1_less_zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'),
     las=1, adj=0)
# title(xlab = "Lag from CASC in Peak Water Level (hr)", line = 2)
title(ylab = "Rank Distance from Main Stem       ", outer = TRUE, line = 4.5)
title(main = " < 0", cex.main = 1, font = 1)

boxplot(lag_cond ~ rank, data = lags_wo_1zero, horizontal = TRUE,
        col = "grey", bg = "grey", xlab = "", ylab = "",
        xlim = c(6.5,0.5), yaxt = "n")
abline(v = 0, lwd = 1.5)
# axis(2, at=c(1:6), labels=c('1: HA02','2: HA12','3: HA15','4: HA10','5: HA08','6: HA07'), las=1, adj=0)
title(sub = "Lag from CASC in Peak Water Level (hr)", outer = TRUE, line = 2)
title(main = "Floods where HA07 or HA08 Lag Time", outer = TRUE, 
      cex.main = 1, font = 1, line = 0)
title(main = " > 0", cex.main = 1, font = 1)
dev.off()

mean_lag <- lags_1_less_zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]

mean_lag <- lags_wo_1zero %>%
  group_by(sensor) %>%
  summarise(mean_lag = median(na.omit(lag_hr)))

mean_lag <- merge(mean_lag, rank, by = "sensor")
mean_lag[order(mean_lag$rank),]






# Look at correlations with various time lags
# Create a cross correlation
start <- "2013-01-01"
end   <- ""

# A ts object is required for this. Have to make sure the time periods overlap
ts.level.6 <- level[[1]]$level_m[level[[1]]$datetime >= as.POSIXct(start, tz = 'MST')]
ts.level.9 <- level[[2]]$level_m[level[[2]]$datetime >= as.POSIXct(start, tz = 'MST')]

main <- ts.intersect(level[[1]],level[[2]])

# For testing functions below
start_date <- "2015-03-25"
end_date   <- "2015-04-25"

# Function to find the time difference between peak water level in the main stem and max change in conductivity of the groundwater wells
gw_lags <- function(start_date, end_date){
  # Define period of time containing flood
  start <- as.POSIXct(start_date, tz = "MST")
  end   <- as.POSIXct(end_date, tz = "MST")

  png(paste0("./Figures/Flood Figures/GW Level Cond_", start_date,"_", end_date, ".png"), units = "in", width = 6, height = 12, res = 100, bg = "transparent")
  par(mfrow = c(7,1), oma = c(1,1,1,0), mar = c(1,5,0,2))
  
  tmp <- level[[1]][level[[1]]$datetime >= start & level[[1]]$datetime <= end,]
  casc_max_lev  <- max(na.omit(tmp$level_m))
  casc_time_max <- tmp[match(casc_max_lev, tmp$level_m), "datetime"]
  
  tmp <- cond[[1]][cond[[1]]$datetime >= start & cond[[1]]$datetime <= end,]
  min_cond  <- min(na.omit(tmp$cond))
  min_cond_time <- tmp[match(min_cond, tmp$cond), "datetime"]
  
  lapply(seq_along(cond), function(i){
    c.tmp <- cond[[i]][cond[[i]]$datetime >= start & cond[[i]]$datetime <= end,]
    l.tmp <- level[[i]][level[[i]]$datetime >= start & level[[i]]$datetime <= end,]
    plot(c.tmp$datetime, c.tmp$cond, xlab = " ", ylab = "Cond (mS)", 
         xlim = c(start, end), xaxs = 'i',
         cex.lab = 2, cex.axis = 2, pch = 19, xaxt = 'n')
    par(new = T)
    plot(l.tmp$datetime, l.tmp$level_m, xlab = " ", ylab = " ", col = "grey",
         xlim = c(start, end), xaxs = 'i', pch = 19, xaxt = 'n', yaxt = 'n')
    abline(v = casc_time_max, lwd = 2, col = "red")
    abline(v = min_cond_time, lwd = 2, col = "blue")
    mtext(paste(temp[1,1], sep = '_'), side = 4,
          line = 1, cex = 1.5)
    box(lwd = 2)
    })
  
  breaks <- pretty(c(0,as.numeric(difftime(end, start))), n = 3) * 60 * 60 * 24
  axis(side = 1, at = c(start + breaks), 
       labels = format(start + breaks, "%m-%d"), cex.axis = 2)
  # x.coord <- start + as.numeric(difftime(end, start)) / 2 * 60 * 60 * 24
  # legend(xcoord, , pch = 19, col = c("black", "grey"),
  #        legend = c("Cond", "Level"), horiz = TRUE, bty = 'n')
  
  dev.off()
}

lag_1 <- gw_lags("2015-03-25", "2015-04-14")
lag_2 <- gw_lags("2014-11-21", "2014-12-31")
lag_3 <- gw_lags("2014-05-01", "2014-05-10")
lag_5 <- gw_lags("2014-04-01", "2014-04-15")
lag_6 <- gw_lags("2014-03-01", "2014-03-31")

# This just yields a bunch of very busy plots

```

